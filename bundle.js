/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/***/ (() => {

eval("let x = 0.1, y = 0, z = 0; // Initial values\nlet sigma = 10, rho = 28, beta = 8 / 3; // Parameters\nlet defaultDT = 0.01; // Time step\nlet points = []; // Store points to draw the attractor\nlet alpha = 0.01;\nlet steps = 1;\nlet pulsation = 0;\nlet zoom = 10;\nlet opacity = 1;\nlet justPoints = false;\nlet fadeOverTime = true;\nlet changeColourOverTime = false;\nlet colourPulsation = false;\nconst gui = new dat.GUI();\n\n\n\n\n// Set up the object to hold all the parameters for the GUI\nconst params = {\n    sigma: 10.0,\n    rho: 28.0,\n    beta: 8.0 / 3.0,\n    dt: 0.01,\n    steps: 1,\n    pulsation: 0,\n    zoom: 10,\n    opacity: 1,\n    justPoints: false,\n    fadeOverTime: true,\n    changeColourOverTime: false,\n    colourPulsation: false\n};\ngui.add(params, 'sigma', 0, 100).onChange(function(value) {\n    sigma = value;\n});\ngui.add(params, 'rho', 0, 100).onChange(function(value) {\n    rho = value;\n});\ngui.add(params, 'beta', 0, 10).onChange(function(value) {\n    beta = value;\n});\ngui.add(params, 'dt', 0.001, 0.02).step(0.001).onChange(function(value) {\n    defaultDT = value;\n});\ngui.add(params, 'steps', 1, 50).step(1).onChange(function(value) {\n    steps = value;\n});\ngui.add(params, 'pulsation', 0, 2).step(0.1).onChange(function(value) {\n    pulsation = value;\n});\ngui.add(params, 'opacity', 0.01, 1).step(0.01).onChange(function(value) {\n    opacity = value;\n});\ngui.add(params, 'zoom', 1, 100).step(1).onChange(function(value) {\n    zoom = value;\n});\ngui.add(params, 'justPoints').name('Draw Points Only').onChange(function(value) {\n    justPoints = value; \n});\ngui.add(params, 'fadeOverTime').name('Fade Over Time').onChange(function(value) {\n    fadeOverTime = value; \n});\ngui_colourtime = gui.add(params, 'changeColourOverTime').listen().name('Change Colour By Coordinate').onChange(function(value) {\n    if(value){\n        changeColourOverTime = true;\n        colourPulsation = false;\n    }else{\n        changeColourOverTime = false;\n    }\n    gui_colourpulse.updateDisplay();\n    \n});\ngui_colourpulse = gui.add(params, 'colourPulsation').listen().name('Change Colour Over Time').onChange(function(value) {\n    if(value){\n        changeColourOverTime = false;\n        colourPulsation = true;\n    }else{\n        colourPulsation = false;\n    }\n    gui_colourtime.updateDisplay();\n    \n});\n\n\nconst reset = () => {\n    points = [];\n    x = 0.1;\n    y = 0;\n    z = 0;\n    zoom = 10;\n    offset = { x: 0, y: 0 };\n\n}\n\ngui.add({reset: reset}, 'reset').name('Reset');\n\nfunction updateLorenz(dt, steps) {\n    for(let i = 0; i < steps; i++){\n        let dx = sigma * (y - x) * dt;\n        let dy = (x * (rho - z) - y) * dt;\n        let dz = (x * y - beta * z) * dt;\n\n        x += dx;\n        y += dy;\n        z += dz;\n        \n        points.push([x, y, z]);\n    }\n    \n    \n    \n}\n\nconst canvas = document.getElementById('canvas2D');\nconst ctx = canvas.getContext('2d');\n\nconst scaleFactor = window.devicePixelRatio || 1;\n\n// Function to resize and center canvas\nfunction resizeCanvas() {\n    canvas.width = window.innerWidth  * scaleFactor;\n    canvas.height = window.innerHeight  * scaleFactor;\n\n    // Match the visible size for CSS\n    canvas.style.width = `${canvas.width / scaleFactor}px`;\n    canvas.style.height = `${canvas.height / scaleFactor}px`;\n\n    ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset any transformations\n    ctx.translate(canvas.width / 2, canvas.height / 2); // Move origin to center\n    \n}\n\nwindow.addEventListener('resize', resizeCanvas);\nresizeCanvas();\nctx.linJoin = 'round';\nctx.lineCap = 'round';\n\n\n\n// Scale the 2D context to match the device pixel ratio\nctx.scale(scaleFactor, scaleFactor);\n\n\n\n// Variables to handle dragging\nlet isDragging = false;\nlet dragStart = { x: 0, y: 0 }; // Initial mouse position when dragging starts\nlet offset = { x: 0, y: 0 };    // Offset for rendering the center\n\n\ncanvas.addEventListener('mousedown', (event) => {\n    isDragging = true;\n    dragStart = { x: event.clientX, y: event.clientY }; // Store the initial mouse position\n});\n\ncanvas.addEventListener('mousemove', (event) => {\n    if (isDragging) {\n        // Calculate how much the mouse has moved\n        const dx = event.clientX - dragStart.x;\n        const dy = event.clientY - dragStart.y;\n\n        // Update the offset\n        offset.x += dx / zoom;\n        offset.y += dy / zoom;\n\n        // Update the drag start position to the current position\n        dragStart = { x: event.clientX, y: event.clientY };\n    }\n});\n\ncanvas.addEventListener('mouseup', () => {\n    isDragging = false; // Stop dragging\n});\n\nfunction draw2D() {\n    ctx.clearRect(-canvas.width / 2, -canvas.height / 2, canvas.width, canvas.height);\n    \n\n    lineWidth = 1 + Math.sin(Date.now() / 500) * pulsation;\n    \n    ctx.lineWidth = lineWidth;\n    if (justPoints) {\n        points.forEach(([px, py], index) => {\n            let screenX = (px + offset.x) * zoom;\n            let screenY = (py + offset.y) * zoom;\n\n            ctx.beginPath();\n            ctx.arc(screenX, screenY, 1, 0, Math.PI * 2);\n\n            let fade = fadeOverTime ? Math.min(opacity, alpha + (index / points.length) * 0.9) : opacity;\n            if(changeColourOverTime){\n                \n                ctx.fillStyle = `rgba(${125 - (px * 10)}, ${125 + (py * 10)}, 125, ${fade})`;\n                \n            }\n            else if(colourPulsation){\n                ctx.fillStyle = `rgba(${125 + 125 * (Math.sin((index + 300) / 200))}, ${125 + 125 * (Math.sin((index + 600) / 300))},${125 + 125 * (Math.cos(index / 400))}, ${fade})`;\n            }\n            else{\n                ctx.fillStyle = `rgba(0, 0, 255, ${fade})`;\n            }\n            \n            ctx.fill();\n        });\n    } else{\n        if (!changeColourOverTime && !colourPulsation){\n            ctx.beginPath();\n            points.forEach(([px, py], index) => {\n                \n                // Scale and center the points\n                let screenX = (px + offset.x) * zoom;\n                let screenY = (py + offset.y) * zoom;\n\n                let fade = fadeOverTime ? Math.min(opacity, alpha + (index / points.length) * 0.9) : opacity;\n\n                ctx.strokeStyle = `rgba(251, 99, 118, ${fade})`;\n                \n                ctx.lineTo(screenX, screenY);\n        \n            });\n            ctx.stroke();\n        }\n        else if(changeColourOverTime){\n            points.forEach(([px, py], index) => {\n                if (index === 0) return; \n            \n                \n                let [prevX, prevY] = points[index - 1];\n                let screenXPrev = (prevX + offset.x) * zoom;\n                let screenYPrev = (prevY + offset.y) * zoom;\n                let screenX = (px + offset.x) * zoom;\n                let screenY = (py + offset.y) * zoom;\n            \n                \n                let fade = fadeOverTime ? Math.min(opacity, alpha + (index / points.length) * 0.9) : opacity;\n            \n                \n                ctx.strokeStyle = `rgba(${125 - (px * 10)}, ${125 + (py * 10)}, 125, ${fade})`;\n            \n                // Draw a line segment\n                ctx.beginPath(); // Start a new path\n                ctx.moveTo(screenXPrev, screenYPrev); // Move to the previous point\n                ctx.lineTo(screenX, screenY); // Draw to the current point\n                ctx.stroke(); // Stroke the segment\n            });\n            \n        }else{\n            points.forEach(([px, py], index) => {\n                if (index === 0) return; \n            \n                \n                let [prevX, prevY] = points[index - 1];\n                let screenXPrev = (prevX + offset.x) * zoom;\n                let screenYPrev = (prevY + offset.y) * zoom;\n                let screenX = (px + offset.x) * zoom;\n                let screenY = (py + offset.y) * zoom;\n            \n                \n                let fade = fadeOverTime ? Math.min(opacity, alpha + (index / points.length) * 0.9) : opacity;\n            \n                \n                ctx.strokeStyle = `rgba(${125 + 125 * (Math.sin((index + 300) / 200))}, ${125 + 125 * (Math.sin((index + 600) / 300))},${125 + 125 * (Math.cos(index / 400))}, ${fade})`;\n            \n                // Draw a line segment\n                ctx.beginPath(); // Start a new path\n                ctx.moveTo(screenXPrev, screenYPrev); // Move to the previous point\n                ctx.lineTo(screenX, screenY); // Draw to the current point\n                ctx.stroke(); // Stroke the segment\n            });\n        }\n        \n    }\n    \n    \n}\n\n\n\n\n\nfunction animate(){\n    updateLorenz(defaultDT,steps);\n    draw2D();\n    \n    requestAnimationFrame(animate);\n}\nconsole.log(\"running\");\nanimate();\n\n//# sourceURL=webpack:///./src/main.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/main.js"]();
/******/ 	
/******/ })()
;